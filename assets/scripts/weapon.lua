--Script generated by GroveW

lightDamage = 5.0
strongDamage = 10.0

leftFist = {positionRel = {x = 0.6, y = 0.0, z = 0.4}, attackTimeStamp = 0.0, pressed = false, pressedTimeStamp = 0.0,
 isAttacking = false, coroutine = {}, damage = lightDamage * damageMultiplier, isStrong = false}
rightFist = {positionRel = {x = -0.6, y = 0.0, z = 0.4}, attackTimeStamp = 0.0, pressed = false, pressedTimeStamp = 0.0,
 isAttacking = false, coroutine = {}, damage = lightDamage * damageMultiplier, isStrong = false}

fists = {} --[1] for left, [2] for right

defaultDepth = 0.0

currentCombination = {}
detectedCombo = "none"
comboDamage = 50.0

loadFistTime = 0.4

timeForComboDecrease = 5.0
comboDecreaseTimeStamp = 0.0

function weaponStart()
    defaultDepth = getBoundingBoxDepth(entity, componentManager)
    setBoundingBox(entity, componentManager, false)
    table.insert(fists, entity)
end

function weaponUpdate(dt)

    if time - comboDecreaseTimeStamp >= timeForComboDecrease then
        if #currentCombination > 0 then 
            table.remove( currentCombination, 1 )
        end
    end

    local fist = fists[1] == entity and leftFist or rightFist

    if detectedCombo == "none" or detectedCombo == "detected" then
        setPositionRelativeToPlayer(fist)
    end

    handleAttack(dt, fist)
    handleCombos(dt)
end

function setPositionRelativeToPlayer(fist)
    setTransformRelToRotatingParent(entity, componentManager, player.position.x, player.position.y, player.position.z, 
    fist.positionRel.x, fist.positionRel.y, fist.positionRel.z,
    player.rotation.x, player.rotation.y, player.rotation.z)
end

function handleAttack(dt, fist)
    if rightFist.isAttacking == false and leftFist.isAttacking == false and detectedCombo ~= "none" then
        return
    end

    if fist.pressed == true and time - fist.pressedTimeStamp >= loadFistTime then
        fist.damage = strongDamage * damageMultiplier
        fist.isStrong = true
        setColor(entity, componentManager, 1.0, 0.0, 0.0)
    end

    if fist.pressed == false and fist.isAttacking == false and isMousePressed(fist) == true then
        fist.pressed = true
        fist.pressedTimeStamp = time
    elseif fist.pressed == true and fist.isAttacking == false and isMousePressed(fist) == false then
        fist.pressed = false
        fist.isAttacking = true
        attackCo = coroutine.create(attackCoroutine)
        fist.coroutine = attackCo
        coroutine.resume( fist.coroutine, dt, fist )
            
    elseif fist.isAttacking == true then
        coroutine.resume( fist.coroutine, dt, fist )
    end
    
end

function attackCoroutine(dt, fist)

    setBoundingBox(entity, componentManager, true)
    fist.attackTimeStamp = time

    while fist.positionRel.z < 1.5 do
        fist.positionRel.z = fist.positionRel.z + (40.0 * dt)
        dt = coroutine.yield()
    end
    fist.positionRel.z = 1.5

    while time - fist.attackTimeStamp < 0.1 do
        dt = coroutine.yield()
    end

    setBoundingBox(entity, componentManager, false)

    while fist.positionRel.z > 0.4 do
        fist.positionRel.z = fist.positionRel.z - (40.0 * dt)
        dt = coroutine.yield()
    end
    fist.positionRel.z = 0.4
    
    fist.isAttacking = false

    if fist.isStrong == true then
        setColor(entity, componentManager, 1.0, 1.0, 1.0)
        fist.damage = lightDamage * damageMultiplier
        fist.isStrong = false
    end
end

function lerp(p0, p1, t)
    return (1 - t) * p0 + t * p1
end

function isMousePressed( fist )
    if fist == leftFist then
        return leftMousePressed
    elseif fist == rightFist then
        return rightMousePressed
    end
end

function handleCombos(dt)
    
    if detectedCombo ~= "none" and leftFist.isAttacking == false 
    and rightFist.isAttacking == false and entity == fists[1] then
        coroutine.resume(comboCo, dt)
        return
    end

    if #currentCombination == 3 then
        local combo = checkCombos()
        if combo ~= "none" then

            detectedCombo = "detected"

            for i, move in ipairs(currentCombination) do
                currentCombination[i] = nil
            end

            if combo == "whirlwind" then
                comboCo = coroutine.create(whirlwindCoroutine)
            elseif combo == "dash1" or combo == "dash2" then
                comboCo = coroutine.create(dashCoroutine)
            end

            if leftFist.isAttacking == false and rightFist.isAttacking == false then
                coroutine.resume(comboCo, dt)
            end
        else
            table.remove(currentCombination, 1)
        end
    end
end

-- combos = { ["whirlwind"] = {"SA", "LA", "LD"},
--            ["dash1"]      = {"LL", "LL", "SR"},
--            ["dash2"]      = {"LR", "LR", "SL"}}
function checkCombos()
    for i, combo in pairs(combos) do
        if checkCombo(combo) == true then
            return i
        end
    end

    return "none"
end

function checkCombo(combo)
    for j, action in ipairs(currentCombination) do
        local power = string.sub( combo[j], 1, 1 )
        local type = string.sub( combo[j], 2, 2 )
        local actionPower = string.sub( action, 1, 1 )
        local actionType = string.sub( action, 2, 2 )

        if power ~= actionPower or type ~= 'D' and type ~= 'A' and type ~= actionType or j > 1 and type == 'D' 
        and currentCombination[j] == currentCombination[j-1] then
            return false
        end

    end

    return true
end